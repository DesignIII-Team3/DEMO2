/*
******************************************************************************
File:     main.c
Info:     Generated by Atollic TrueSTUDIO(R) 9.3.0   2023-02-21
******************************************************************************
*/

#include "stm32f4xx.h"
#include "pwm_driver.h"
#include "input_capture_config.h"
#include "wheels_control.h"
#include "speed_control_loop.h"
#include "macros_utiles.h"

#define F_CLK SystemCoreClock
#define MAX_DUTY_CYCLE 130
#define MIN_DUTY_CYCLE 20
#define RELEASE_ANGLE 60
#define GRAB_ANGLE 180

int grabber_angle = RELEASE_ANGLE;
int counter;

#define M1PWM_FREQ        1000
#define M1PWM_PERIOD      ((26880000 / M1PWM_FREQ) - 1)

#define M2PWM_FREQ        1000
#define M2PWM_PERIOD      ((26880000 / M2PWM_FREQ) - 1)

#define M3PWM_FREQ        1000
#define M3PWM_PERIOD      ((26880000 / M3PWM_FREQ) - 1)

#define M4PWM_FREQ        1000
#define M4PWM_PERIOD      ((26880000 / M4PWM_FREQ) - 1)

//PI controller parameters
float M1_Kp = 0.2942;
float M1_Ki = 5.768;

float M2_Kp = 0.55;
float M2_Ki = 4.706;

float M3_Kp = 0.2892;
float M3_Ki = 6.568;

float M4_Kp = 0.512;
float M4_Ki = 6.838;


// Constants for motor speed control
float M1desired_speed = 0;// Desired motor speed in RPS
float M2desired_speed = 0;// Desired motor speed in RPS
float M3desired_speed = 0;// Desired motor speed in RPS
float M4desired_speed = 0;// Desired motor speed in RPS

// Variables for PI controller
float M1error = 0.0;
float M1prev_error = 0.0;
float M1integral = 0.0;
float M1output = 0.0;

float M2error = 0.0;
float M2prev_error = 0.0;
float M2integral = 0.0;
float M2output = 0.0;

float M3error = 0.0;
float M3prev_error = 0.0;
float M3integral = 0.0;
float M3output = 0.0;

float M4error = 0.0;
float M4prev_error = 0.0;
float M4integral = 0.0;
float M4output = 0.0;


uint32_t CH1_IC_Val1 = 0;
uint32_t CH1_IC_Val2 = 0;
uint32_t CH1_Difference = 0;
int CH1_Is_First_Captured = 0;
float M1measured_frequency = 0;
float M1desired_frequency = 0;

uint32_t CH2_IC_Val1 = 0;
uint32_t CH2_IC_Val2 = 0;
uint32_t CH2_Difference = 0;
int CH2_Is_First_Captured = 0;
float M2measured_frequency = 0;
float M2desired_frequency = 0;

uint32_t CH3_IC_Val1 = 0;
uint32_t CH3_IC_Val2 = 0;
uint32_t CH3_Difference = 0;
int CH3_Is_First_Captured = 0;
float M3measured_frequency = 0;
float M3desired_frequency = 0;

uint32_t CH4_IC_Val1 = 0;
uint32_t CH4_IC_Val2 = 0;
uint32_t CH4_Difference = 0;
int CH4_Is_First_Captured = 0;
float M4measured_frequency = 0;
float M4desired_frequency = 0;

void setM1desiredSpeed(float speed){
	M1desired_speed = speed;
}

 void setM2desiredSpeed(float speed){
	M2desired_speed = speed;
}

void setM3desiredSpeed(float speed){
	M3desired_speed = speed;
}

void setM4desiredSpeed(float M4desiredspeed){
	M4desired_speed = M4desiredspeed;
}

void TIM6_DAC_IRQHandler(){

	if (GPIOE->IDR & BIT7)
	{
		TIM6->SR &= ~TIM_SR_UIF;

			M1desired_frequency = M1desired_speed * 1600;
			M1error = M1desired_frequency - M1measured_frequency;
			M1integral += M1error*0.0001;
			M1output = M1_Kp * M1error + M1_Ki * M1integral;
			M1prev_error = M1error;
			float M1_duty_cycle = M1_Kp * M1error + M1_Ki * M1integral;
			if (M1_duty_cycle > 100)
				M1_duty_cycle = 100;
			else if (M1_duty_cycle < 0)
				M1_duty_cycle = 0;
			TIM4->CCR1 = (M1_duty_cycle / 100) * (M1PWM_PERIOD + 1);

			M2desired_frequency = M2desired_speed * 1600;
			M2error = M2desired_frequency - M2measured_frequency;
			M2integral += M2error*0.0001;
			M2output = M2_Kp * M2error + M2_Ki * M2integral;
			M2prev_error = M2error;
			float M2_duty_cycle = M2_Kp * M2error + M2_Ki * M2integral;
			if (M2_duty_cycle > 100)
				M2_duty_cycle = 100;
			else if (M2_duty_cycle < 0)
				M2_duty_cycle = 0;
			TIM4->CCR2 = (M2_duty_cycle / 100) * (M2PWM_PERIOD + 1);

			M3desired_frequency = M3desired_speed * 1600;
			M3error = M3desired_frequency - M3measured_frequency;
			M3integral += M3error*0.0001;
			M3output = M3_Kp * M3error + M3_Ki * M3integral;
			M3prev_error = M3error;
			float M3_duty_cycle = M3_Kp * M3error + M3_Ki * M3integral;
			if (M3_duty_cycle > 100)
				M3_duty_cycle = 100;
			else if (M3_duty_cycle < 0)
				M3_duty_cycle = 0;
			TIM4->CCR3 = (M3_duty_cycle / 100) * (M3PWM_PERIOD + 1);

			M4desired_frequency = M4desired_speed * 1600;
			M4error = M4desired_frequency - M4measured_frequency;
			M4integral += M4error*0.0001;
			M4output = M4_Kp * M4error + M4_Ki * M4integral;
			M4prev_error = M4error;
			float M4_duty_cycle = M4_Kp * M4error + M4_Ki * M4integral;
			if (M4_duty_cycle > 100)
				M4_duty_cycle = 100;
			else if (M4_duty_cycle < 0)
				M4_duty_cycle = 0;
			TIM4->CCR4 = (M4_duty_cycle / 100) * (M4PWM_PERIOD + 1);
	}


}

void TIM5_IRQHandler(void){
	if (TIM5->SR & TIM_SR_CC1IF)
	{
		if(CH1_Is_First_Captured == 0){
			CH1_IC_Val1 = TIM5->CCR1;
			CH1_Is_First_Captured = 1;
		}
		else{
			CH1_IC_Val2 = TIM5->CCR1;
			if(CH1_IC_Val2 > CH1_IC_Val1){
				CH1_Difference = CH1_IC_Val2 - CH1_IC_Val1;
			}
			else if(CH1_IC_Val1 > CH1_IC_Val2){
				CH1_Difference = (0xFFFFFFFF - CH1_IC_Val1) + CH1_IC_Val2;
			}
			float CH1refClock = 26880000.f;
			M1measured_frequency = CH1refClock/CH1_Difference;
			TIM5->SR &= ~TIM_SR_CC1IF;
			CH1_Is_First_Captured = 0;
		}
	}
	if (TIM5->SR & TIM_SR_CC2IF)
	{
		if(CH2_Is_First_Captured == 0){
			CH2_IC_Val1 = TIM5->CCR2;
			CH2_Is_First_Captured = 1;
		}
		else{
			CH2_IC_Val2 = TIM5->CCR2;
			if(CH2_IC_Val2 > CH2_IC_Val1){
				CH2_Difference = CH2_IC_Val2 - CH2_IC_Val1;
			}
			else if(CH2_IC_Val1 > CH2_IC_Val2){
				CH2_Difference = (0xFFFFFFFF - CH2_IC_Val1) + CH2_IC_Val2;

			}
			float CH2refClock = 26880000.f;
			M2measured_frequency = CH2refClock/CH2_Difference;
			TIM5->SR &= ~TIM_SR_CC2IF;
			CH2_Is_First_Captured = 0;
		}
	}
	if (TIM5->SR & TIM_SR_CC3IF)
	{
		if(CH3_Is_First_Captured == 0){
			CH3_IC_Val1 = TIM5->CCR3;
			CH3_Is_First_Captured = 1;
		}
		else{
			CH3_IC_Val2 = TIM5->CCR3;
			if(CH3_IC_Val2 > CH3_IC_Val1){
				CH3_Difference = CH3_IC_Val2 - CH3_IC_Val1;
			}
			else if(CH3_IC_Val1 > CH3_IC_Val2){
				CH3_Difference = (0xFFFFFFFF - CH3_IC_Val1) + CH3_IC_Val2;

			}
			float CH3refClock = 26880000.f;
			M3measured_frequency = CH3refClock/CH3_Difference;
			TIM5->SR &= ~TIM_SR_CC3IF;
			CH3_Is_First_Captured = 0;
		}
	}
	if (TIM5->SR & TIM_SR_CC4IF)
	{
		if(CH4_Is_First_Captured == 0){
			CH4_IC_Val1 = TIM5->CCR4;
			CH4_Is_First_Captured = 1;
		}
		else{
			CH4_IC_Val2 = TIM5->CCR4;
			if(CH4_IC_Val2 > CH4_IC_Val1){
				CH4_Difference = CH4_IC_Val2 - CH4_IC_Val1;
			}
			else if(CH4_IC_Val1 > CH4_IC_Val2){
				CH4_Difference = (0xFFFFFFFF - CH4_IC_Val1) + CH4_IC_Val2;

			}
			float CH4refClock = 26880000.f;
			M4measured_frequency = CH4refClock/CH4_Difference;
			TIM5->SR &= ~TIM_SR_CC4IF;
			CH4_Is_First_Captured = 0;
		}
	}
}

void configGPIOInput(void)
{
	RCC->AHB1ENR |= BIT4;
	GPIOE->MODER &= ~(BIT14|BIT15);

	//GPIO D1 D2 D3 D4 POUR LE CW CCW
	RCC->AHB1ENR |= BIT3;
	GPIOD->MODER |= (BIT2 | BIT4 | BIT6 | BIT8| BIT10 | BIT12 | BIT14 | BIT16);
}

void Gripper_SetAngularPosition(int p_angle)
{
	// on refuse les angles non compris dans l'interval [0, 180]
	//if( !(0 <= p_angle && p_angle <= 180) ) return;

	 float duty_cycle = (p_angle*11/18)+20;
	 TIM12->CCR1 = round(duty_cycle);
}

void Gripper_release()
{
	counter = 0;
	timer_on();

	int angle = GRAB_ANGLE;

	Gripper_SetAngularPosition( 0 );
	while( counter < 50 );

	/*
	for(angle; angle >= RELEASE_ANGLE; angle-=20){
		Gripper_SetAngularPosition( angle );

		while(counter <= 10);
		counter = 0;
	}
	*/

	timer_off();
}


void Gripper_grab()
{
	counter = 0;
	timer_on();

	int angle = RELEASE_ANGLE;

	Gripper_SetAngularPosition( GRAB_ANGLE );
	while(counter < 50);
	/*
	for(angle; angle <= GRAB_ANGLE; angle+=20){
		Gripper_SetAngularPosition( angle );

		while(counter <= 10);
		counter = 0;
	}
	*/

	if(!limitSwitchConfig()){	// check si bloc a ete saisi
								// si non relever le prehenseur
		Gripper_release();
	}

	//timer_off();
}

void configureGPIOB14(void){

	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOBEN;

	//GPIOB->MODER &= ~GPIO_MODER_MODER14;
	//GPIOB->MODER |= (GPIO_MODER_MODER14_1);
	GPIOB->AFR[1] |= (GPIO_AF_TIM12 << 24);
	GPIOB->OTYPER &= ~GPIO_OTYPER_OT_14;


	// Activer la broche PC10 en mode alternatif de fonctionnement
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;		// open drain pour pouvoir avoir la sortie sur 5V
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;	//
	GPIO_Init(GPIOB, &GPIO_InitStructure);

	/*
	// Configurer la broche PB14 pour fonctionner avec le Timer 1
	GPIO_PinAFConfig(GPIOB, GPIO_PinSource14, GPIO_AF_TIM12);
	*/
}

void configureGPIOC7(void){
	RCC->AHB1ENR |= BIT2;  // Enable Clock on Port C
	// ------ GPIOC config in input ----------
	GPIOC->MODER &=  ~(BIT14|BIT15);
	GPIOC->PUPDR &= ~(BIT14|BIT15);	// no pull up no pull down
}

int limitSwitchConfig(void){
	if( !(GPIOC->IDR & BIT7) ){
		//uart_sendString("Cube is on the system\n");
		return 1;
	}
	else{
		//uart_sendString("Cube is off the system\n");
	}

	return 0;
}

void TIM12_CH1_PWM_Init(void)
{

	// Enable clock for TIM1 peripheral
	RCC->APB1ENR |= RCC_APB1ENR_TIM12EN;


	TIM12->PSC = 538 - 1;									// Set prescaler to 84
	TIM12->ARR = 1000 -1;										// Set auto-reload value to 999

	// Enable PWM mode 1 on channel 1
	TIM12->CCMR1 &= ~TIM_CCMR1_OC1M;
	TIM12->CCMR1 |= TIM_CCMR1_OC1M_2 | TIM_CCMR1_OC1M_1;

	// Enable preload register on channel 1
	TIM12->CCMR1 |= TIM_CCMR1_OC1PE;

	// Enable capture/compare channel 1
	TIM12->CCER |= TIM_CCER_CC1E;

	TIM12->DIER |= TIM_DIER_UIE;								// enble interrupt
	NVIC_EnableIRQ(TIM8_BRK_TIM12_IRQn);					// active les interruption du timer


	/*
	// Configurer le Timer 12 pour une sortie PWM
	TIM12->PSC = 0;  // Pas de division de fréquence
	TIM12->ARR = 1000;  // Période de la PWM
	TIM12->CCR1 = 500;  // Rapport cyclique initial
	TIM12->CCMR1 |= TIM_CCMR1_OC1M_1 | TIM_CCMR1_OC1M_2;  // Mode PWM1
	TIM12->CCER |= TIM_CCER_CC1E;  // Active la sortie CC1
	TIM12->CR1 |= TIM_CR1_CEN;  // Active le Timer 12\
	*/
}

void TIM8_BRK_TIM12_IRQHandler()
{
	TIM12->SR &= ~TIM_SR_UIF;
	counter++;
}

void timer_on()
{
	TIM12->CR1 |= TIM_CR1_CEN;
}

void timer_off()
{
	TIM12->CR1 &= ~TIM_CR1_CEN;
}

int main(void)
{
 	TIM4_CH1_PWM_Init();
	configureGPIOB6();
	TIM4_CH2_PWM_Init();
	configureGPIOB7();
	TIM4_CH3_PWM_Init();
	configureGPIOB8();
	TIM4_CH4_PWM_Init();
	configureGPIOB9();
	TIM4->CR1 |= TIM_CR1_CEN;

	TIM5_CH1_IC_Init();
	configureGPIOA0();
	TIM5_CH2_IC_Init();
	configureGPIOA1();
	TIM5_CH3_IC_Init();
	configureGPIOA2();
	TIM5_CH4_IC_Init();
	configureGPIOA3();
	TIM5->CR1 |= TIM_CR1_CEN;

	configGPIOInput();

	configureTIM6();
	configureWheelsDirection();

	TIM12_CH1_PWM_Init();
	configureGPIOB14();
	configureGPIOC7();
	//uart_configure();

	Gripper_SetAngularPosition( RELEASE_ANGLE );
	// Set capture compare value 2 to 50
	TIM3->CCR2 = 50;


  while (1)
  {

	  //AVANCER, PAUSE, CHANGER CW pour CCW, RECULER, PAUSE
	  GPIOD->ODR = (BIT1|BIT4); //AVANCE
	  for (int i = 0; i < 600000 ; i++)
	  {
		  setM1desiredSpeed(0.5);
		  setM2desiredSpeed(0);
		  setM3desiredSpeed(0.5);
		  setM4desiredSpeed(0);
	  }
	  for (int j = 0; j < 300000 ; j++)
	  {
		  setM1desiredSpeed(0);
		  setM2desiredSpeed(0);
		  setM3desiredSpeed(0);
		  setM4desiredSpeed(0);
	  }

	  Gripper_grab();

	  for (int j = 0; j < 300000 ; j++)
	  {
		  setM1desiredSpeed(0);
		  setM2desiredSpeed(0);
		  setM3desiredSpeed(0);
		  setM4desiredSpeed(0);
	  }

	  GPIOD->ODR = (BIT2|BIT4); //RECULE
	  for (int i = 0; i < 600000 ; i++)
	  {
		  setM1desiredSpeed(0.45);
		  setM2desiredSpeed(0.45);
		  setM3desiredSpeed(0.45);
		  setM4desiredSpeed(0.45);
	  }
	  for (int j = 0; j < 300000 ; j++)
	  {
		  setM1desiredSpeed(0);
		  setM2desiredSpeed(0);
		  setM3desiredSpeed(0);
		  setM4desiredSpeed(0);
	  }

	  GPIOD->ODR = (BIT1|BIT4); //AVANCE
	  	  for (int i = 0; i < 600000 ; i++)
	  	  {
	  		  setM1desiredSpeed(0.5);
	  		  setM2desiredSpeed(0);
	  		  setM3desiredSpeed(0.5);
	  		  setM4desiredSpeed(0);
	  	  }
	  	  for (int j = 0; j < 300000 ; j++)
	  	  {
	  		  setM1desiredSpeed(0);
	  		  setM2desiredSpeed(0);
	  		  setM3desiredSpeed(0);
	  		  setM4desiredSpeed(0);
	  	  }

	  	  Gripper_release();

	  	for (int j = 0; j < 300000 ; j++)
			  {
				  setM1desiredSpeed(0);
				  setM2desiredSpeed(0);
				  setM3desiredSpeed(0);
				  setM4desiredSpeed(0);
			  }

	  	GPIOD->ODR = (BIT2|BIT3); //RECULE
	  		  for (int i = 0; i < 600000 ; i++)
	  		  {
	  			  setM1desiredSpeed(0.5);
	  			  setM2desiredSpeed(0);
	  			  setM3desiredSpeed(0.5);
	  			  setM4desiredSpeed(0);
	  		  }

	  		for (int j = 0; j < 300000 ; j++)
	  			  			  {
	  			  				  setM1desiredSpeed(0);
	  			  				  setM2desiredSpeed(0);
	  			  				  setM3desiredSpeed(0);
	  			  				  setM4desiredSpeed(0);
	  			  			  }

	  		  GPIOD->ODR = (BIT2|BIT4); //RECULE
	  		  for (int i = 0; i < 600000 ; i++)
	  		  {
	  			  setM1desiredSpeed(0.45);
	  			  setM2desiredSpeed(0.45);
	  			  setM3desiredSpeed(0.45);
	  			  setM4desiredSpeed(0.45);
	  		  }

	  		for (int j = 0; j < 300000 ; j++)
	  			  {
	  				  setM1desiredSpeed(0);
	  				  setM2desiredSpeed(0);
	  				  setM3desiredSpeed(0);
	  				  setM4desiredSpeed(0);
	  			  }

  }
}
