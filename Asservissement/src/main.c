/*
******************************************************************************
File:     main.c
Info:     Generated by Atollic TrueSTUDIO(R) 9.3.0   2023-02-21
******************************************************************************
*/

#include "stm32f4xx.h"
#include "pwm_driver.h"
#include "input_capture_config.h"
#include "wheels_control.h"
#include "speed_control_loop.h"



#define M1PWM_FREQ        1000
#define M1PWM_PERIOD      ((26880000 / M1PWM_FREQ) - 1)

#define M2PWM_FREQ        1000
#define M2PWM_PERIOD      ((26880000 / M2PWM_FREQ) - 1)

#define M3PWM_FREQ        1000
#define M3PWM_PERIOD      ((26880000 / M3PWM_FREQ) - 1)

#define M4PWM_FREQ        1000
#define M4PWM_PERIOD      ((26880000 / M4PWM_FREQ) - 1)

//PI controller parameters
float M1_Kp = 0.2942;
float M1_Ki = 5.768;

float M2_Kp = 0.55;
float M2_Ki = 4.706;

float M3_Kp = 0.2892;
float M3_Ki = 6.568;

float M4_Kp = 0.512;
float M4_Ki = 6.838;


// Constants for motor speed control
float M1desired_speed = 0;// Desired motor speed in RPS
float M2desired_speed = 0;// Desired motor speed in RPS
float M3desired_speed = 0;// Desired motor speed in RPS
float M4desired_speed = 0;// Desired motor speed in RPS

// Variables for PI controller
float M1error = 0.0;
float M1prev_error = 0.0;
float M1integral = 0.0;
float M1output = 0.0;

float M2error = 0.0;
float M2prev_error = 0.0;
float M2integral = 0.0;
float M2output = 0.0;

float M3error = 0.0;
float M3prev_error = 0.0;
float M3integral = 0.0;
float M3output = 0.0;

float M4error = 0.0;
float M4prev_error = 0.0;
float M4integral = 0.0;
float M4output = 0.0;


uint32_t CH1_IC_Val1 = 0;
uint32_t CH1_IC_Val2 = 0;
uint32_t CH1_Difference = 0;
int CH1_Is_First_Captured = 0;
float M1measured_frequency = 0;
float M1desired_frequency = 0;

uint32_t CH2_IC_Val1 = 0;
uint32_t CH2_IC_Val2 = 0;
uint32_t CH2_Difference = 0;
int CH2_Is_First_Captured = 0;
float M2measured_frequency = 0;
float M2desired_frequency = 0;

uint32_t CH3_IC_Val1 = 0;
uint32_t CH3_IC_Val2 = 0;
uint32_t CH3_Difference = 0;
int CH3_Is_First_Captured = 0;
float M3measured_frequency = 0;
float M3desired_frequency = 0;

uint32_t CH4_IC_Val1 = 0;
uint32_t CH4_IC_Val2 = 0;
uint32_t CH4_Difference = 0;
int CH4_Is_First_Captured = 0;
float M4measured_frequency = 0;
float M4desired_frequency = 0;

void setM1desiredSpeed(float speed){
	M1desired_speed = speed;
}

void setM2desiredSpeed(float speed){
	M2desired_speed = speed;
}

void setM3desiredSpeed(float speed){
	M3desired_speed = speed;
}

void setM4desiredSpeed(float M4desiredspeed){
	M4desired_speed = M4desiredspeed;
}

uint32_t countTIM = 0;
void TIM6_DAC_IRQHandler(){
	TIM6->SR &= ~TIM_SR_UIF;
	countTIM++;

	M1desired_frequency = M1desired_speed * 1600;
	M1error = M1desired_frequency - M1measured_frequency;
	M1integral += M1error*0.0001;
	M1output = M1_Kp * M1error + M1_Ki * M1integral;
	M1prev_error = M1error;
	float M1_duty_cycle = M1_Kp * M1error + M1_Ki * M1integral;
	if (M1_duty_cycle > 100)
		M1_duty_cycle = 100;
	else if (M1_duty_cycle < 0)
		M1_duty_cycle = 0;
	TIM4->CCR1 = (M1_duty_cycle / 100) * (M1PWM_PERIOD + 1);

	M2desired_frequency = M2desired_speed * 1600;
	M2error = M2desired_frequency - M2measured_frequency;
	M2integral += M2error*0.0001;
	M2output = M2_Kp * M2error + M2_Ki * M2integral;
	M2prev_error = M2error;
	float M2_duty_cycle = M2_Kp * M2error + M2_Ki * M2integral;
	if (M2_duty_cycle > 100)
		M2_duty_cycle = 100;
	else if (M2_duty_cycle < 0)
		M2_duty_cycle = 0;
	TIM4->CCR2 = (M2_duty_cycle / 100) * (M2PWM_PERIOD + 1);

	M3desired_frequency = M3desired_speed * 1600;
	M3error = M3desired_frequency - M3measured_frequency;
	M3integral += M3error*0.0001;
	M3output = M3_Kp * M3error + M3_Ki * M3integral;
	M3prev_error = M3error;
	float M3_duty_cycle = M3_Kp * M3error + M3_Ki * M3integral;
	if (M3_duty_cycle > 100)
		M3_duty_cycle = 100;
	else if (M3_duty_cycle < 0)
		M3_duty_cycle = 0;
	TIM4->CCR3 = (M3_duty_cycle / 100) * (M3PWM_PERIOD + 1);

	M4desired_frequency = M4desired_speed * 1600;
	M4error = M4desired_frequency - M4measured_frequency;
	M4integral += M4error*0.0001;
	M4output = M4_Kp * M4error + M4_Ki * M4integral;
	M4prev_error = M4error;
	float M4_duty_cycle = M4_Kp * M4error + M4_Ki * M4integral;
	if (M4_duty_cycle > 100)
		M4_duty_cycle = 100;
	else if (M4_duty_cycle < 0)
		M4_duty_cycle = 0;
	TIM4->CCR4 = (M4_duty_cycle / 100) * (M4PWM_PERIOD + 1);

}

void TIM5_IRQHandler(void){
	if (TIM5->SR & TIM_SR_CC1IF)
	{
		if(CH1_Is_First_Captured == 0){
			CH1_IC_Val1 = TIM5->CCR1;
			CH1_Is_First_Captured = 1;
		}
		else{
			CH1_IC_Val2 = TIM5->CCR1;
			if(CH1_IC_Val2 > CH1_IC_Val1){
				CH1_Difference = CH1_IC_Val2 - CH1_IC_Val1;
			}
			else if(CH1_IC_Val1 > CH1_IC_Val2){
				CH1_Difference = (0xFFFFFFFF - CH1_IC_Val1) + CH1_IC_Val2;
			}
			float CH1refClock = 26880000.f;
			M1measured_frequency = CH1refClock/CH1_Difference;
			TIM5->SR &= ~TIM_SR_CC1IF;
			CH1_Is_First_Captured = 0;
		}
	}
	if (TIM5->SR & TIM_SR_CC2IF)
	{
		if(CH2_Is_First_Captured == 0){
			CH2_IC_Val1 = TIM5->CCR2;
			CH2_Is_First_Captured = 1;
		}
		else{
			CH2_IC_Val2 = TIM5->CCR2;
			if(CH2_IC_Val2 > CH2_IC_Val1){
				CH2_Difference = CH2_IC_Val2 - CH2_IC_Val1;
			}
			else if(CH2_IC_Val1 > CH2_IC_Val2){
				CH2_Difference = (0xFFFFFFFF - CH2_IC_Val1) + CH2_IC_Val2;

			}
			float CH2refClock = 26880000.f;
			M2measured_frequency = CH2refClock/CH2_Difference;
			TIM5->SR &= ~TIM_SR_CC2IF;
			CH2_Is_First_Captured = 0;
		}
	}
	if (TIM5->SR & TIM_SR_CC3IF)
	{
		if(CH3_Is_First_Captured == 0){
			CH3_IC_Val1 = TIM5->CCR3;
			CH3_Is_First_Captured = 1;
		}
		else{
			CH3_IC_Val2 = TIM5->CCR3;
			if(CH3_IC_Val2 > CH3_IC_Val1){
				CH3_Difference = CH3_IC_Val2 - CH3_IC_Val1;
			}
			else if(CH3_IC_Val1 > CH3_IC_Val2){
				CH3_Difference = (0xFFFFFFFF - CH3_IC_Val1) + CH3_IC_Val2;

			}
			float CH3refClock = 26880000.f;
			M3measured_frequency = CH3refClock/CH3_Difference;
			TIM5->SR &= ~TIM_SR_CC3IF;
			CH3_Is_First_Captured = 0;
		}
	}
	if (TIM5->SR & TIM_SR_CC4IF)
	{
		if(CH4_Is_First_Captured == 0){
			CH4_IC_Val1 = TIM5->CCR4;
			CH4_Is_First_Captured = 1;
		}
		else{
			CH4_IC_Val2 = TIM5->CCR4;
			if(CH4_IC_Val2 > CH4_IC_Val1){
				CH4_Difference = CH4_IC_Val2 - CH4_IC_Val1;
			}
			else if(CH4_IC_Val1 > CH4_IC_Val2){
				CH4_Difference = (0xFFFFFFFF - CH4_IC_Val1) + CH4_IC_Val2;

			}
			float CH4refClock = 26880000.f;
			M4measured_frequency = CH4refClock/CH4_Difference;
			TIM5->SR &= ~TIM_SR_CC4IF;
			CH4_Is_First_Captured = 0;
		}
	}
}


int main(void)
{
	TIM4_CH1_PWM_Init();
	configureGPIOB6();
	TIM4_CH2_PWM_Init();
	configureGPIOB7();
	TIM4_CH3_PWM_Init();
	configureGPIOB8();
	TIM4_CH4_PWM_Init();
	configureGPIOB9();
	TIM4->CR1 |= TIM_CR1_CEN;

	TIM5_CH1_IC_Init();
	configureGPIOA0();
	TIM5_CH2_IC_Init();
	configureGPIOA1();
	TIM5_CH3_IC_Init();
	configureGPIOA2();
	TIM5_CH4_IC_Init();
	configureGPIOA3();
	TIM5->CR1 |= TIM_CR1_CEN;

	configureTIM6();
	configureWheelsDirection();

  while (1)
  {

  }
}
